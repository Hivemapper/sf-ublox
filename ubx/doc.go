// Package ubx contains definitions for UBX-XXX-YYY messages and functions to decode and encode them.
//
// Definitions of message and bit field types, as well as the unittests are generated by the program msggen,
// also found in this directory, from an XML file constructed from a text dump of the PDF manual, with some
// hand-parsing of the bitfield defining images in there.
//
// The the generating program, the XML file messages.xml and templates are provided here, but not required
// for operation or building the package.
//
// The UBX message protocol has clearly evolved under the hands of many interns who lost track of any
// underlying design principles that may have been present at it's inception. The lowest layer is a
// framing protocol with a prefix, a type code (message class and message id), a lenght and a trailing
// checksum. However the class and ID do not uniquely determine the message type.  For most messages
// the length provides sufficient clue as to what the incoming type should be, but some messages contain
// variable parts, some contain a field that says how many elements of the variable part there are but
// some don't. One contains 2 variable parts, one has a variable and an optional part which may add up
// to the same number, and some messages have some sort of further subtype encoded in the first field
// of the message. Since the XML file didn't capture that, for those messages the file mkmsg.go contains
// functions called by decode to construct them.
//
// At Daedalean we have the convention to suffix numeric variable names with an encoding of the units.
// This package follows that convention even if go lint may whine.
//
//  Source:
// 		u-blox 8 / u-blox M8 Receiver description (UBX-13003221)  R21 (dc62240) 25 September 2020
// 		https://www.u-blox.com/sites/default/files/products/documents/u-blox8-M8_ReceiverDescrProtSpec_%28UBX-13003221%29.pdf
//
package ubx
